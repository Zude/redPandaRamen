'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

exports.validateHtml = validateHtml;
exports.validateCss = validateCss;

var _htmlValidator = require('html-validator');

var _htmlValidator2 = _interopRequireDefault(_htmlValidator);

var _w3cCss = require('w3c-css');

var _w3cCss2 = _interopRequireDefault(_w3cCss);

var _ressourceUtils = require('./ressource-utils');

var _helper = require('./helper');

var _customError = require('./customError.js');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function validateHtml(result) {
	var options = { format: 'text', data: result.html };

	return (0, _htmlValidator2.default)(options).then(function (evaluation) {

		if ((0, _helper.isDefined)(evaluation) && (evaluation.includes('Error:') || evaluation.includes('Warning:'))) {
			throw (0, _customError.HtmlValidationError)(evaluation, result.html);
		} else {
			return _promise2.default.resolve(result);
		}
	}).catch(function (error) {
		if ((0, _helper.isDefined)(error)) {
			if ((0, _customError.isConnectionError)(error)) {
				console.log("Warning (HTML): could not establish internet connection to the html validator: validation skipped.");
			} else {
				throw (0, _customError.HtmlValidationError)(error, result.html);
			}
		}
		return _promise2.default.resolve(result);
	});
}

//TODO: Breaks, if contains relative paths
function validateCss(result) {
	var regex = /(<link.*href=\")(.*.css)(\")/g;
	var match = regex.exec(result.html);
	var queue = _promise2.default.resolve(result);

	while (match != null) {
		var pathToFile = match[2].startsWith('/') ? match[2].substr(1) : match[2];

		if (!pathToFile.includes('http')) {
			if ((0, _ressourceUtils.exists)(pathToFile)) {
				(function () {
					var file = (0, _ressourceUtils.openFile)(pathToFile);
					var cssValidatorOptions = {
						text: file,
						profile: "css3",
						warning: 1
					};

					queue = queue.then(function (_) {
						return new _promise2.default(function (resolve, reject) {
							_w3cCss2.default.validate(cssValidatorOptions, function (error, evaluation) {
								if ((0, _helper.isDefined)(error)) {
									if ((0, _customError.isConnectionError)(error)) {
										console.log("Warning (CSS): could not establish internet connection to the css validator: validation skipped.");
										resolve(result);
									} else {
										reject((0, _customError.CssValidationError)(error, result.html));
									}
								} else if ((0, _helper.isDefined)(evaluation) && (0, _helper.isDefined)(evaluation.errors) && evaluation.errors.length > 0) {
									var msg = evaluation.errors.map(function (err) {
										return err.message.trim() + ' (in line ' + err.line + ')';
									}).join('\n');
									reject((0, _customError.CssValidationError)(msg, result.html, file));
								} else if ((0, _helper.isDefined)(evaluation) && (0, _helper.isDefined)(evaluation.warnings) && evaluation.warnings.length > 0) {
									// TODO: render Warning Page
									var _msg = evaluation.warnings.map(function (err) {
										return err.message.trim() + ' (in line ' + err.line + ')';
									}).join('\n');
									reject((0, _customError.CssValidationError)(_msg, result.html, file));
								} else {
									resolve(result);
								}
							});
						});
					});
				})();
			} else {
				return _promise2.default.reject((0, _customError.FileNotFoundError)('Could not find Stylesheet ' + pathToFile));
			}
		}

		match = regex.exec(result.html);
	}

	return queue;
}
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

exports.reloadDatabase = reloadDatabase;
exports.parseFrontmatter = parseFrontmatter;
exports.compile = compile;

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _promisedHandlebars = require('promised-handlebars');

var _promisedHandlebars2 = _interopRequireDefault(_promisedHandlebars);

var _handlebars = require('handlebars');

var _handlebars2 = _interopRequireDefault(_handlebars);

var _customError = require('./customError');

var _ressourceUtils = require('./ressource-utils');

var _helper = require('./helper');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function registerCustomHelpers(handlebarsEnv) {
	var helpersDirectory = 'helpers';
	var regex = /(.+)(.js)/; // only *.js files with at least one character filenames

	if ((0, _ressourceUtils.exists)(helpersDirectory)) {
		var allHelpers = []; // element := { modulename, funcname }
		(0, _ressourceUtils.listFiles)(helpersDirectory).forEach(function (filename) {
			var match = regex.exec(filename);

			if (match) {
				var modulename = match[1];
				var module = (0, _ressourceUtils.loadDynamicModule)(modulename, helpersDirectory);
				if (module instanceof Error) {
					throw module;
				}

				(0, _keys2.default)(module).forEach(function (funcname) {
					var newHelper = { modulename: modulename, funcname: funcname };

					allHelpers.forEach(function (cur) {
						if (cur.funcname === newHelper.funcname) {
							throw (0, _customError.HelperAlreadyDeclared)('Helper "' + newHelper.funcname + '" declared in "' + newHelper.modulename + '.js" already declared in "' + cur.modulename + '.js"');
						}
					});
					allHelpers.push(newHelper);

					handlebarsEnv.registerHelper(funcname, function () {
						var args = [].concat(Array.prototype.slice.call(arguments));
						args.pop(); // last argument contains an options object, we do not need it here
						return module[funcname].apply(module, (0, _toConsumableArray3.default)(args));
					});
				});
			}
		});
	}
}

/**
 * Calculates a meaningfully indented version of the
 * current context.
 */
function registerGlobalHelpers(handlebarsEnv) {
	handlebarsEnv.registerHelper('debugJson', function (context, options) {
		var pageData = context.data.root;
		var toReturn = '<pre>' + (0, _stringify2.default)(pageData, null, 2) + '</pre>';
		return new _handlebars2.default.SafeString(toReturn);
	});
}

function createHandlebarsEnv() {
	//const handlebarsEnv = handlebars.create();
	var handlebarsEnv = (0, _promisedHandlebars2.default)(_handlebars2.default);

	registerGlobalHelpers(handlebarsEnv);
	registerCustomHelpers(handlebarsEnv);

	return handlebarsEnv;
}
/*
const Sequelize = require('sequelize');
const sequelize = new Sequelize('database', null, null, {
	dialect: 'sqlite',
	storage: 'data/database.db'
});
sequelize
	.authenticate()
	.then( _ => {
		console.log('Connected to database.');
	});
*/
// TODO: figure out how to reload database only if database is for a page/fragment request needed. Otherwise t
function reloadDatabase() {
	return new _promise2.default(function (resolve, reject) {
		resolve(true);
	});
}
/*
function runSql(key, maybeSql, params) {
	return new Promise((resolve, reject) => {
		sequelize.query(maybeSql,
			{ replacements: params }
		).then(result => {
			resolve({[key]: unpackSqlResult(result[0])});
		})
		.catch(error => {
			resolve({[key]: maybeSql});
		})
	});
}

// TODO: Zurzeit wird eine "/data/database.sql" Datei erwartet. Mehrere Dateien erlauben? Wie sinnvoll verknÃ¼pfen?
function parseAndExecuteSql(frontmatter, requestParams) {
	const params = mergeObjects(requestParams.path, requestParams.get, requestParams.post);

    return new Promise((resolve, reject) => {
        let promises = Object.keys(frontmatter).map(key => {
            return runSql(key, frontmatter[key], params);
        });

        Promise.all(promises).then(values => {
            resolve(objectFlatMap(values));
        });
    });
}
*/
// Todo: global configuration "onlyJson"/"onlyYaml"/"both"
function parseFrontmatter(frontmatter, filename, requestParams) {
	var result = {};
	/*
 if (isJson(frontmatter)) {
        result= parseJson(frontmatter, filename);
 } else if (isYaml(frontmatter)) {
        result = parseYaml(frontmatter, filename);
 } else {
        throw WrongFiletypeError(`Wrong filestructure in file ${filename}. It neither contains well-formed json or yaml.`);
 }
 */
	if ((0, _helper.isJson)(frontmatter)) {
		result = (0, _helper.parseJson)(frontmatter, filename);
	} else {
		throw (0, _customError.WrongFiletypeError)('Wrong filestructure in file ' + filename + '. It does not contain well-formed json.');
	}

	/*result = parseAndExecuteSql(result, requestParams);*/

	return new _promise2.default(function (resolve, reject) {
		resolve(result);
	});
}

// kein 'precompile' von Handlebars!
function prepareCompile(url, startDir, frontmatter) {
	console.log('prepareCompile', url);
	var preparedUrl = (0, _ressourceUtils.convert)(url);
	var filename = _path2.default.basename(preparedUrl);
	var directory = _path2.default.join(startDir, _path2.default.dirname(preparedUrl));

	console.log('Going to compile file ' + filename + ' from directory ' + directory);

	if ((0, _ressourceUtils.exists)(directory) && (0, _ressourceUtils.contains)(directory, filename)) {

		var file = _fs2.default.readFileSync(_path2.default.join(directory, filename), 'utf8');
		var fileSplitted = file.split('---');

		var fmatter = fileSplitted.length > 1 ? fileSplitted[0] : '{}';
		var hbs = fileSplitted.length > 1 ? fileSplitted[1] : fileSplitted[0];

		return parseFrontmatter(fmatter, filename, frontmatter.request).then(function (frontmatterLocal) {
			var page = (0, _assign2.default)({}, frontmatter.page, frontmatterLocal);
			var frontmatterCombined = (0, _assign2.default)({}, { page: page }, { global: frontmatter.global }, { request: frontmatter.request }, { session: frontmatter.session });

			console.log('Output for       : ' + url);
			console.log('Frontmatter JSON : ' + (0, _stringify2.default)(frontmatterLocal));
			console.log('Complete JSON    : ' + (0, _stringify2.default)(frontmatterCombined));
			console.log('\n');

			return _promise2.default.resolve({ hbs: hbs, frontmatterCombined: frontmatterCombined });
		});
	} else {
		throw (0, _customError.FileNotFoundError)('File ' + filename + ' not found in Directory ' + directory);
	}
}

function compile(url) {
	var frontmatter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	var dir = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'pages';
	var contentHtml = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';

	return prepareCompile(url, dir, frontmatter).then(function (compiled) {
		var hbs = compiled.hbs,
		    frontmatterCombined = compiled.frontmatterCombined;


		var handlebarsEnv = createHandlebarsEnv();

		handlebarsEnv.registerHelper('content', function () {
			return new handlebarsEnv.SafeString(contentHtml);
		});

		handlebarsEnv.registerHelper('include', function (fname) {
			return compile(fname, frontmatterCombined, 'templates').then(function (html) {
				return new handlebarsEnv.SafeString(html);
			});
		});

		var templateName = '';
		if ('template' in frontmatterCombined['page']) {
			templateName = frontmatterCombined['page']['template'];
			delete frontmatterCombined['page']['template'];
		}

		var template = handlebarsEnv.compile(hbs);
		return template(frontmatterCombined).then(function (htmlCompiled) {
			if (templateName !== '') {
				return compile(templateName, frontmatterCombined, 'templates', htmlCompiled);
			} else {
				return _promise2.default.resolve(htmlCompiled);
			}
		}).then(function (htmlCompiled) {
			return _promise2.default.resolve(htmlCompiled.length === 0 ? " " : htmlCompiled.trim());
		});
	});
}
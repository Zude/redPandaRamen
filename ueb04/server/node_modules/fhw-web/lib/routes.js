'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

exports.default = prepareRoutes;

var _ressourceUtils = require('./ressource-utils');

var _customError = require('./customError');

var _helper = require('./helper');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var HttpMethods = ['get', 'post', 'put', 'patch', 'delete'];

var magicRoutes = [{
	"url": "/*",
	"static": "/*"
}, {
	"url": "/*",
	"page": "*"
}];

function prepareRoutes(config) {
	var routeDefinitions = {};

	if (config.magicRoutes) {
		routeDefinitions = JSON.parse((0, _stringify2.default)(magicRoutes));
	} else if (config.routes) {
		routeDefinitions = JSON.parse((0, _stringify2.default)(config.routes));
	} else {
		routeDefinitions = (0, _ressourceUtils.loadJson)('routes.json');
		if (!routeDefinitions) {
			throw (0, _customError.JsonParseError)('routes.json', 'Could not read routes.json file.');
		}
	}

	// TODO: Mit Sternchen umgehen
	// TODO: was, wenn url === "" ? Ist das schlimm?
	// TODO: URL-String sowie PAGE-String validieren

	var routes = routeDefinitions.map(function (definition, index) {
		var modified = (0, _helper.copy)(definition);

		if ((0, _helper.isUndefined)(definition.url)) {
			throw (0, _customError.RouteDefinitionError)('Route no. ' + index + ': missing url definition.');
		} else if (definition.url.split('*').length > 2) {
			throw (0, _customError.RouteDefinitionError)('Route no. ' + index + ': url definition contains more than one wildecard "*".');
		}
		if ((0, _helper.isDefined)(definition.method)) {
			if (!(0, _helper.isArray)(definition.method)) {
				throw (0, _customError.RouteDefinitionError)('Route no. ' + index + ': method definition has to be an array of supported http methods.');
			}
			modified.method = definition.method.map(function (method) {
				var m = method.toLowerCase();
				if (!HttpMethods.includes(m)) {
					throw (0, _customError.RouteDefinitionError)('Route no. ' + index + ': invalid method "' + method + '" declared.');
				}
				return m;
			});
		} else {
			modified.method = ['get'];
		}
		if (!((0, _helper.isDefined)(definition.static) || (0, _helper.isDefined)(definition.page) || (0, _helper.isDefined)(definition.controller))) {
			throw (0, _customError.RouteDefinitionError)('Route no. ' + index + ': one of those definitions (static, page or controller) is required.');
		}
		if ((0, _helper.isDefined)(definition.static) && (0, _helper.isDefined)(definition.page)) {
			throw (0, _customError.RouteDefinitionError)('Route no. ' + index + ': both, "static" and "page" are declared, but only one of those definitions one the same route are supported.');
		}
		if ((0, _helper.isDefined)(definition.static) && (0, _helper.isDefined)(definition.controller)) {
			throw (0, _customError.RouteDefinitionError)('Route no. ' + index + ': both, "static" and "controller" are declared, but only one of those definitions one the same route are supported.');
		}
		if ((0, _helper.isDefined)(definition.page) && (0, _helper.isDefined)(definition.controller)) {
			throw (0, _customError.RouteDefinitionError)('Route no. ' + index + ': both, "page" and "controller" are declared, but only one of those definitions one the same route are supported.');
		}
		if ((0, _helper.isDefined)(definition.static)) {
			modified.static = definition.static[0] === '/' ? definition.static : '/' + definition.static;
		}
		if ((0, _helper.isDefined)(definition.params)) {
			if ((0, _helper.isDefined)(definition.params.get)) {
				if (!(0, _helper.isArray)(definition.params.get)) {
					throw (0, _customError.RouteDefinitionError)('Route no. ' + index + ': params.get has to be an array.');
				}
			} else {
				modified.params.get = [];
			}
			if ((0, _helper.isDefined)(definition.params.post)) {
				if (!(0, _helper.isArray)(definition.params.post)) {
					throw (0, _customError.RouteDefinitionError)('Route no. ' + index + ': params.post has to be an array.');
				}
			} else {
				modified.params.post = [];
			}
		} else {
			modified.params = { path: [], get: [], post: [] };
		}
		if ((0, _helper.isDefined)(definition.controller)) {
			if ((0, _helper.isUndefined)(definition.controller.file) || (0, _helper.isUndefined)(definition.controller.function)) {
				throw (0, _customError.RouteDefinitionError)('Route no. ' + index + ': controller definition is wrong.');
			}
		}

		var pathParams = [];
		var urlRegex = definition.url;

		urlRegex = urlRegex.includes('*') ? urlRegex.replace('*', function (_) {
			return '(.*)';
		}) : urlRegex;

		urlRegex = urlRegex.includes(':') ? urlRegex.replace(/:[a-zA-Z]*/g, function (match) {
			pathParams.push(match.substr(1));
			return '[^\/]*';
		}) : urlRegex;
		urlRegex = '^' + urlRegex + '$';
		modified.urlRegex = urlRegex;
		modified.params.path = pathParams;

		return modified;
	});

	return _promise2.default.resolve(routes);
}